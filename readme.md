# Проект "Умная теплица"
## Авторы - студенты ТюмГУ ИБ-22.02
- Гбетоо Ромен - проектирование и разработка БД
- Егоров Семён - разработка главного удалённого сервера и механизмов общения устройств
- Кочнев Артём - разработка Back-End web-сервера
- Москалева Алёна - проектирование и разработка ботов IoT-устройств
- Новожилов Егор - проектирование и разработка IoT-сервера
- Панова Злата - разработка Front-End web-сервера
- Шледевиц Виктор - общая архитектура и компановка проекта, документирование



## Краткое описание файлов проекта
### IoT-устройства
- /bots/uuids - хранит UUID каждого устройства в отдельных файлах
- /bots/config.py - хранит конфигурацию для работы ботов, а также шифрования
- /bots/DBMS_worker.py - класс для взаимодействия с БД
- /bots/device.py - базовый класс, на основе которого создаются все IoT-устройства
- /bots/encryption.py - функции шифрования/дешифрования
- /bots/IoT_devices.py - перечень и конфигурация различных IoT-устройств
- /bots/logic.py - вспомогательные функции, у нас работа с UUID
- /bots/main.py - точка входа. Создаёт устройства и запускает каждое в отдельном потоке
### Веб-сокет-сервер
- /servers/IoT-server/config.py - хранит конфигурацию для работы сервера, а также шифрования
- /servers/IoT-server/DBMS_worker.py - класс для взаимодействия с БД
- /servers/IoT-server/encryption.py - функции шифрования/дешифрования
- /servers/IoT-server/main.py - реализация и точка входа для локального веб-сокет-сервера
### Главный удалённый сервер
- /servers/main-server/config.py - хранит конфигурацию для работы сервера, а также шифрования
- /servers/main-server/DBMS_worker.py - класс для взаимодействия с БД
- /servers/main-server/encryption.py - функции шифрования/дешифрования
- /servers/main-server/main.py - реализация и точка входа для главного удалённого сервера
### Веб-сервер
- /servers/web-server/css/styles.css - хранит стили HTML-документов веб-сервера
- /servers/web-server/templates/base.html - хранит шаблон HTML. Содержит стили, меню
- /servers/web-server/templates/dashboard.html - содержит главную страницу с актуальной информацией
- /servers/web-server/templates/devices.html - внезапно, управление IoT-устройствами
- /servers/web-server/templates/devices.html - хранит страницу истории наблюдений
- /servers/web-server/templates/login.html - содержит страницу входа
- /servers/web-server/templates/register.html - содержит страницу регистрации
- /servers/web-server/templates/rules.html - содержит страницу конфигурации правил
- /servers/web-server/templates/sectors.html - содержит страницу конфигурации секторов(теплиц)
- /servers/web-server/app.py - содержит реализацию веб-сервера на основе Flask
- /servers/web-server/config.py - хранит конфигурацию для работы сервера, а также шифрования
- /servers/web-server/DBMS_worker.py - класс для взаимодействия с БД
- /servers/web-server/encryption.py - функции шифрования/дешифрования
### Прочее
- /db_schema.png - ERD всех баз данных
- /readme.md - справочная информация, призванная упростить понимание принципов работы проекта
- /requirements.txt - библиотеки, фреймворки и пр. с используемыми версиями
- /run.sh - скрипт запуска всех систем, включая ботов + mariadb при необходимости



## Алгоритм работы конечного пользователя с системой
1. Запросить и получить IoT-устройства, роутер
2. Установить всё ПО на локальный компьютер
3. Получить подписку
4. Пройти локальную регистрацию
5. Создать секторы для своих(ей) теплиц(ы)
6. Распределить устройства по секторам
7. Задать правила автоматизации



## Детализация
### Функциональные компоненты системы
1. IoT-устройства
2. IoT-сервер
3. web-сервер
4. Главный сервер

### Работа с базой данных
Для решения всех задач хранения данных была выбрана СУБД **MySQL(mariadb)**
IoT-сервер и web-server имеют доступ к локальной базе данных, все действия совершают над ней
Главный сервер также обладает собственной базой данных, доступ к ней имеет лишь администратор
Для упрощения симуляции была создана БД и для ботов IoT-устройств
Все связи изображены в db_schema.png
Взаимодействие с СУБД из Python реализуется с помощью mysql.connector
Отказоустойчивость обеспечивается использованием пула подключений
Реализованы классы для взаимодействия с БД с простым интерфейсом в каждом компоненте системы
Написан триггер для автоматического пополнения таблицы истории замеров при обновлении актуальных данных
#### БД IoT-устройств
1. Таблица "indicators" - виртуальная теплица, хранит текущие показания по секторам
#### БД IoT- и web-сервера
1. Таблица "sectors" - хранит данные о секторах
2. Таблица "devices" - хранит данные об устройствах
3. Таблица "actual_data" - хранит данные о текущих показаниях системы
4. Таблица "data_history" - хранит историю замеров каждого устройства
5. Таблица "rules" - хранит правила автоматизации
6. Таблица "users" - хранит локальные учётные записи
#### БД главного удалённого сервера
1. Таблица "users" - хранит данные о подписке для каждого пользователя

### Главный удалённый сервер
С ним устанавливают соединение web-серверы теплиц, чтобы определить наличие подписки
Для этого общения используется HTTP, данные сериализуются в JSON и шифруются алгоритмом AES с обеих сторон
В ответ на каждый запрос отправляется JSON формата {"active": True, "until": datetime} в случае успеха и {"active": False, "reason": str} в случае неудачи
Управление подписками осуществляется прямым взаимодействием с таблицей "users"

Общая конфигурация:
1. MAIN_SERV_ADDR - адрес текущего сервера
2. MAIN_SERV_PORT - порт текущего сервера
3. ENCRYPTION_KEY - ключ шифрования

### Транспорт сообщений
Данные -> JSON -> AES -> HTTP-socket -> HTTP-socket -> AES -> JSON -> Данные
Сериализация и десереализация JSON осуществляется средствами стандартной библиотеки json
Алгоритм шифрования AES был выбран из-за низких требований к ресурсам, возможности выполнения на большинстве IoT-устройств и приемлемого уровня безопасности. Реализуется внешним модулем Crypto.Cipher.AES
Сетевое взаимодействие реализуется стандартной библиотекой socket

### Back-End web-сервера
Построен на фреймворке Flask, выбран из-за легковесности и лёгкости разработки
Применяется механизм сессий для хранения аутентификационных данных
Для каждой страницы применяется декоратор login_required, устанавливающий соединение с удалённым сервером и проверяющий факт наличия подписки
Реализован ряд функций преобразования данных из БД в JSON формата, требуемого Front-End

Общая конфигурация:
1. REMOTE_SERV_ADDR - адрес главного удалённого сервера с подписками
2. REMOTE_SERV_PORT - порт главного удалённого сервера
3. ENCRYPTION_KEY - ключ шифрования для общения с главным удалённым сервером

### Front-End web-сервера
Реализован стандартной связкой HTML+CSS+JS, применён Jinja2 для автоматической интеграции данных с Back-End. Графики строятся средствами chart.js
Применён механизм flush-сообщений для уведомления пользователя о событиях
Данные, как правило, подгружаются на страницу с Back-End в формате JSON и средствами Jinja2 размещаются на странице
Каждая страница выполнена в едином стиле, взаимодействие с сетью сведено к минимуму для условий низкой пропускной способности сети
Повсюду применяется "Защита от дурака". Строгий тип полей ввода, защита от случайного удаления

### IoT-устройства
Для упрощения масштабирования был разработан общий родительский класс для каждого устройства
Каждое устройство стремится установить соединение с IoT-сервером, при успехе начинает слать данные о своём текущем состоянии и замеряемых индикаторах
Сервер в ответ отправляет задержку и список команд для исполнения. После исполнения всех команд выжидается задержка и снова отправляются данные на IoT-сервер

Конфигурация каждого устройства:
1. IoT_name - понятное человекочитаемое название устройства, может повторяться
2. uuid_filename - название файла, в котором устройство будет хранить свой уникальный номер
3. sector - номер сектора в таблице "indicators"
4. indicators - массив индикаторов, которые устройство будет считывать в выбранном секторе
5. to_change - параметр, на который устройство может влиять. None при его отсутствии

Общая конфигурация:
1. SERVER_ADDR - адрес IoT-сервера
2. SERVER_PORT - порт IoT-сервера
3. NO_UUID - уникальный номер устройства, в случае, если он ещё не был присвоен сервером
4. RECONNECT_DELAY - задержка между попытками подключения в секундах
5. SEND_STATE_DELAY - задержка между отправкой данных. Обычно, используется задержка, полученная от сервера
6. ERROR_PERCENT - погрешность замерений в процентах для тех устройств, к которым она применима
7. ENCRYPTION_KEY - ключ шифрования для общения с IoT-сервером
8. PASSWORD - пароль для аутентификации на IoT-сервере

### IoT-сервер
Подключение и связь инициируют IoT-устройства. Для каждого создаётся отдельный поток в целях изоляции и реализация асинхронности

Алгоритм подключения IoT-устройства:
1. IoT-устройство устанавливает socket-соединение с сервером
2. Сервер запускает отдельный поток для работы с подключенным устройством
3. Устройство отправляет зашифрованный пароль
4. Если пароль оказывается неверным, соединение разрывается
5. Устройство отправляет своё не обязательно уникальное имя и обязательно уникальный UUID
6. Если отправлен NO_UUID, средствами стандартной библиотеки генерируется новый
7. Устройству отправляется ответ со статусом аутентификации и UUID при необходимости

Алгоритм работы с IoT-устройством:
1. IoT-сервер ждёт сообщение о состоянии
2. Если отправлены данные, IoT-сервер обновит(создаст) запись об этом в БД
3. Для устройства проверяются существующие правила. Если правило сработало, в ответ добавляются команды и переустанавливается задержка. Может быть добавлено несколько команд
4. Сформированный ответ отправляется устройству, переход на пункт 1

Общая конфигурация:
1. NO_UUID - UUID, означающий его отсутствие. Нужен для определения необходимости генерации нового UUID для устройства
2. LOC_SOCK_SERV_ADDR - адрес текущего IoT-сервера
3. LOC_SOCK_SERV_PORT - порт текущего IoT-сервера
4. SEND_STATE_DELAY - задержка, после которой IoT-устройство должно будет связаться с IoT-сервером снова
5. ENCRYPTION_KEY - ключ шифрования для общения с IoT-устройствами
6. PASSWORD - пароль для аутентификации IoT-устройств